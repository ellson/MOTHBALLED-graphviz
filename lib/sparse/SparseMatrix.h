/* $Id$Revision: */
/* vim:set shiftwidth=4 ts=8: */

/*************************************************************************
 * Copyright (c) 2011 AT&T Intellectual Property
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************/
#ifndef SPARSEMATRIX_H
#define SPARSEMATRIX_H

#include <general.h>
#include <stdio.h>

#define SYMMETRY_EPSILON 0.0000001
enum {
  FORMAT_CSC,
  FORMAT_CSR,
  FORMAT_COORD
};
enum {
  UNMASKED = -10,
  MASKED = 1
};
enum {
  MATRIX_PATTERN_SYMMETRIC = 1 << 0,
  MATRIX_SYMMETRIC = 1 << 1,
  MATRIX_SKEW = 1 << 2,
  MATRIX_HERMITIAN = 1 << 3,
  MATRIX_UNDIRECTED = 1 << 4
};
enum {
  BIPARTITE_RECT = 0,
  BIPARTITE_PATTERN_UNSYM,
  BIPARTITE_UNSYM,
  BIPARTITE_ALWAYS
};

struct SparseMatrix_struct {
  int m;  /* row dimension */
  int n;  /* column dimension */
  int nz; /* The actual length used is nz, for CSR/CSC matrix this is the same
             as ia[n] */
  int nzmax; /* the current length of ja and a (if exists) allocated.*/
  int type;  /* whether it is real/complex matrix, or pattern only */
  int *
      ia; /* row pointer for CSR format, or row indices for coordinate format.
             0-based */
  int *ja;    /* column indices. 0-based */
  void *a;    /* entry values. If NULL, pattern matrix */
  int format; /* whether it is CSR, CSC, COORD. By default it is in CSR format
                 */
  int property; /* pattern_symmetric/symmetric/skew/hermitian*/
  int size;     /* size of each entry. This allows for general matrix where each
               entry is, say, a matrix itself */
};

typedef struct SparseMatrix_struct *SparseMatrix;

enum {
  MATRIX_TYPE_REAL = 1 << 0,
  MATRIX_TYPE_COMPLEX = 1 << 1,
  MATRIX_TYPE_INTEGER = 1 << 2,
  MATRIX_TYPE_PATTERN = 1 << 3,
  MATRIX_TYPE_UNKNOWN = 1 << 4
};

/* SparseMatrix_general is more general and allow elements to be
   any data structure, not just real/int/complex etc */
SparseMatrix SparseMatrix_new(int m, int n, int nz, int type, int format);
SparseMatrix SparseMatrix_general_new(int m, int n, int nz, int type, size_t sz,
                                      int format);

/* this version sum repeated entries */
SparseMatrix SparseMatrix_from_coordinate_format(SparseMatrix A);
/* what_to_sum is SUM_REPEATED_NONE, SUM_REPEATED_ALL, SUM_REPEATED_REAL_PART,
 * SUM_REPEATED_IMAGINARY_PART, SUM_IMGINARY_KEEP_LAST_REAL*/
SparseMatrix SparseMatrix_from_coordinate_format_not_compacted(SparseMatrix A,
                                                               int what_to_sum);

SparseMatrix SparseMatrix_from_coordinate_arrays(int nz, int m, int n, int *irn,
                                                 int *jcn, void *val, int type,
                                                 size_t sz);
SparseMatrix SparseMatrix_from_coordinate_arrays_not_compacted(
    int nz, int m, int n, int *irn, int *jcn, void *val, int type, size_t sz,
    int what_to_sum);

void SparseMatrix_print(char *, SparseMatrix A); /*print to stdout in
                                                    Mathematica format*/

void SparseMatrix_export(FILE *f, SparseMatrix A); /* export into MM format
                                                      except the header */

SparseMatrix SparseMatrix_import_binary(char *name);
SparseMatrix SparseMatrix_import_binary_fp(
    FILE *f); /* import into a preopenned file */

void SparseMatrix_export_binary(char *name, SparseMatrix A, int *flag);
void SparseMatrix_export_binary_fp(FILE *f, SparseMatrix A); /* export binary
                                                                into a file
                                                                preopened */

void SparseMatrix_delete(SparseMatrix A);

SparseMatrix SparseMatrix_add(SparseMatrix A, SparseMatrix B);
SparseMatrix SparseMatrix_multiply(SparseMatrix A, SparseMatrix B);
SparseMatrix SparseMatrix_multiply3(SparseMatrix A, SparseMatrix B,
                                    SparseMatrix C);

/* For complex matrix:
   if what_to_sum = SUM_REPEATED_REAL_PART, we find entries {i,j,x + i y} and
   sum the x's if {i,j,Round(y)} are the same
   if what_to_sum = SUM_REPEATED_IMAGINARY_PART, we find entries {i,j,x + i y}
   and sum the y's if {i,j,Round(x)} are the same
   For other matrix, what_to_sum = SUM_REPEATED_REAL_PART is the same as
   what_to_sum = SUM_REPEATED_IMAGINARY_PART
   or what_to_sum = SUM_REPEATED_ALL
   if what_to_sum = SUM_IMGINARY_KEEP_LAST_REAL, we merge {i,j,R1,I1} and
   {i,j,R2,I2} into {i,j,R1+R2,I2}. Useful if I1 and I2 are time stamps,
   .   and we use this to indicate that a user watched R1+R2 seconds, last watch
   is I2.
*/
enum {
  SUM_REPEATED_NONE = 0,
  SUM_REPEATED_ALL,
  SUM_REPEATED_REAL_PART,
  SUM_REPEATED_IMAGINARY_PART,
  SUM_IMGINARY_KEEP_LAST_REAL
};
SparseMatrix SparseMatrix_sum_repeat_entries(SparseMatrix A, int what_to_sum);
SparseMatrix SparseMatrix_coordinate_form_add_entries(SparseMatrix A,
                                                      int nentries, int *irn,
                                                      int *jcn, void *val);
int SparseMatrix_is_symmetric(SparseMatrix A, int test_pattern_symmetry_only);
SparseMatrix SparseMatrix_transpose(SparseMatrix A);
SparseMatrix SparseMatrix_symmetrize(SparseMatrix A,
                                     int pattern_symmetric_only);
SparseMatrix SparseMatrix_symmetrize_nodiag(SparseMatrix A,
                                            int pattern_symmetric_only);
void SparseMatrix_multiply_vector(
    SparseMatrix A, real *v, real **res,
    int transposed); /* if v = NULL, v is assumed to be {1,1,...,1}*/
SparseMatrix SparseMatrix_remove_diagonal(SparseMatrix A);
SparseMatrix SparseMatrix_remove_upper(
    SparseMatrix A); /* remove diag and upper diag */
SparseMatrix SparseMatrix_divide_row_by_degree(SparseMatrix A);
SparseMatrix SparseMatrix_get_real_adjacency_matrix_symmetrized(
    SparseMatrix A); /* symmetric, all entries to 1, diaginal removed */
SparseMatrix SparseMatrix_normalize_to_rowsum1(SparseMatrix A); /* for real
                                                                   only! */
void SparseMatrix_multiply_dense(SparseMatrix A, int ATranspose, real *v,
                                 int vTransposed, real **res, int res_transpose,
                                 int dim);
SparseMatrix SparseMatrix_apply_fun(
    SparseMatrix A, double (*fun)(double x)); /* for real only! */
SparseMatrix SparseMatrix_apply_fun_general(
    SparseMatrix A, void (*fun)(int i, int j, int n,
                                double *x)); /* for real and complex (n=2) */
SparseMatrix SparseMatrix_copy(SparseMatrix A);
int SparseMatrix_has_diagonal(SparseMatrix A);
SparseMatrix SparseMatrix_normalize_by_row(
    SparseMatrix A); /* divide by max of each row */
SparseMatrix SparseMatrix_crop(SparseMatrix A,
                               real epsilon); /*remove any entry <= epsilon*/
SparseMatrix SparseMatrix_scaled_by_vector(SparseMatrix A, real *v,
                                           int apply_to_row);
SparseMatrix SparseMatrix_multiply_by_scaler(SparseMatrix A, real s);
SparseMatrix SparseMatrix_make_undirected(
    SparseMatrix A); /* make it strictly low diag only, and set flag to
                        undirected */
int SparseMatrix_connectedQ(SparseMatrix A);
real SparseMatrix_pseudo_diameter_only(SparseMatrix A);
real SparseMatrix_pseudo_diameter_weighted(SparseMatrix A0, int root,
                                           int aggressive, int *end1, int *end2,
                                           int *connectedQ); /* assume real
                                                                distances,
                                                                unsymmetric
                                                                matrix ill be
                                                                symmetrized */
real SparseMatrix_pseudo_diameter_unweighted(
    SparseMatrix A0, int root, int aggressive, int *end1, int *end2,
    int *connectedQ); /* assume unit edge length, unsymmetric matrix ill be
                         symmetrized */
void SparseMatrix_level_sets(SparseMatrix A, int root, int *nlevel,
                             int **levelset_ptr, int **levelset, int **mask,
                             int reintialize_mask);
void SparseMatrix_level_sets_khops(int khops, SparseMatrix A, int root,
                                   int *nlevel, int **levelset_ptr,
                                   int **levelset, int **mask,
                                   int reintialize_mask);
void SparseMatrix_weakly_connected_components(SparseMatrix A0, int *ncomp,
                                              int **comps, int **comps_ptr);
void SparseMatrix_decompose_to_supervariables(SparseMatrix A, int *ncluster,
                                              int **cluster, int **clusterp);
SparseMatrix SparseMatrix_get_submatrix(SparseMatrix A, int nrow, int ncol,
                                        int *rindices, int *cindices);
SparseMatrix SparseMatrix_exclude_submatrix(SparseMatrix A, int nrow, int ncol,
                                            int *rindices, int *cindices);

SparseMatrix SparseMatrix_get_augmented(SparseMatrix A);

/* bipartite_options:
   BIPARTITE_RECT -- turn rectangular matrix into square),
   BIPARTITE_PATTERN_UNSYM -- pattern unsummetric as bipartite
   BIPARTITE_UNSYM -- unsymmetric as square
   BIPARTITE_ALWAYS -- always as square
*/
SparseMatrix SparseMatrix_to_square_matrix(SparseMatrix A,
                                           int bipartite_options);

SparseMatrix SparseMatrix_largest_component(SparseMatrix A);

/* columns with <= threhold entries are deleted */
SparseMatrix SparseMatrix_delete_empty_columns(SparseMatrix A, int **new2old,
                                               int *nnew, int inplace);
SparseMatrix SparseMatrix_delete_sparse_columns(SparseMatrix A, int threshold,
                                                int **new2old, int *nnew,
                                                int inplace);

SparseMatrix SparseMatrix_sort(SparseMatrix A);

SparseMatrix SparseMatrix_set_entries_to_real_one(SparseMatrix A);

SparseMatrix SparseMatrix_complement(SparseMatrix A, int undirected);

int SparseMatrix_k_centers(SparseMatrix D, int weighted, int K, int root,
                           int **centers, int centering, real **dist);

int SparseMatrix_k_centers_user(SparseMatrix D, int weighted, int K,
                                int *centers_user, int centering, real **dist);

SparseMatrix SparseMatrix_distance_matrix_k_centers(int K, SparseMatrix D,
                                                    int weighted);

int SparseMatrix_distance_matrix(SparseMatrix A, int weighted,
                                 real **dist_matrix);
SparseMatrix SparseMatrix_distance_matrix_khops(int khops, SparseMatrix A,
                                                int weighted);
SparseMatrix SparseMatrix_distance_matrix_k_centers(int K, SparseMatrix D,
                                                    int weighted);

void SparseMatrix_kcoreness(SparseMatrix A,
                            int **coreness); /* assign coreness to each node */
void SparseMatrix_kcore_decomposition(SparseMatrix A, int *coreness_max0,
                                      int **coreness_ptr0,
                                      int **coreness_list0); /* return the
                                                                decomposition */

void SparseMatrix_khairness(SparseMatrix A,
                            int **hairness); /* assign hairness to each node */
void SparseMatrix_khair_decomposition(SparseMatrix A, int *hairness_max0,
                                      int **hairness_ptr0,
                                      int **hairness_list0); /* return the
                                                                decomposition */

SparseMatrix SparseMatrix_from_dense(int m, int n, real *x);

void SparseMatrix_page_rank(SparseMatrix A, real teleport_probablity,
                            int weighted, real epsilon, real **page_rank);

#define SparseMatrix_set_undirected(A) \
  set_flag((A)->property, MATRIX_UNDIRECTED)
#define SparseMatrix_set_symmetric(A) set_flag((A)->property, MATRIX_SYMMETRIC)
#define SparseMatrix_set_pattern_symmetric(A) \
  set_flag((A)->property, MATRIX_PATTERN_SYMMETRIC)
#define SparseMatrix_set_skew(A) set_flag((A)->property, MATRIX_SKEW)
#define SparseMatrix_set_hemitian(A) set_flag((A)->property, MATRIX_HERMITIAN)

#define SparseMatrix_clear_undirected(A) \
  clear_flag((A)->property, MATRIX_UNDIRECTED)
#define SparseMatrix_clear_symmetric(A) \
  clear_flag((A)->property, MATRIX_SYMMETRIC)
#define SparseMatrix_clear_pattern_symmetric(A) \
  clear_flag((A)->property, MATRIX_PATTERN_SYMMETRIC)
#define SparseMatrix_clear_skew(A) clear_flag((A)->property, MATRIX_SKEW)
#define SparseMatrix_clear_hemitian(A) \
  clear_flag((A)->property, MATRIX_HERMITIAN)

#define SparseMatrix_known_undirected(A) \
  test_flag((A)->property, MATRIX_UNDIRECTED)
#define SparseMatrix_known_symmetric(A) \
  test_flag((A)->property, MATRIX_SYMMETRIC)
#define SparseMatrix_known_strucural_symmetric(A) \
  test_flag((A)->property, MATRIX_PATTERN_SYMMETRIC)
#define SparseMatrix_known_skew(A) test_flag((A)->property, MATRIX_SKEW)
#define SparseMatrix_known_hemitian(A) \
  test_flag((A)->property, MATRIX_HERMITIAN)

#endif

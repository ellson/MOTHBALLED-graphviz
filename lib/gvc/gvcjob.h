/* $Id$ $Revision$ */
/* vim:set shiftwidth=4 ts=8: */

/*************************************************************************
 * Copyright (c) 2011 AT&T Intellectual Property
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************/

/* Common header used by both clients and plugins */

#ifndef GVCJOB_H
#define GVCJOB_H

#ifdef __cplusplus
extern "C" {
#endif

#include "gvcommon.h"
#include "color.h"

#define ARRAY_SIZE(A) (sizeof(A) / sizeof(A[0]))

typedef struct gvdevice_engine_s gvdevice_engine_t;
typedef struct gvformatter_engine_s gvformatter_engine_t;
typedef struct gvrender_engine_s gvrender_engine_t;
typedef struct gvlayout_engine_s gvlayout_engine_t;
typedef struct gvtextlayout_engine_s gvtextlayout_engine_t;
typedef struct gvloadimage_engine_s gvloadimage_engine_t;

typedef enum {
  PEN_NONE,
  PEN_DASHED,
  PEN_DOTTED,
  PEN_SOLID
} pen_type;
typedef enum {
  FILL_NONE,
  FILL_SOLID,
  FILL_LINEAR,
  FILL_RADIAL
} fill_type;
typedef enum {
  FONT_REGULAR,
  FONT_BOLD,
  FONT_ITALIC
} font_type;
typedef enum {
  LABEL_PLAIN,
  LABEL_HTML
} label_type;

#define PENWIDTH_NORMAL 1.
#define PENWIDTH_BOLD 2.
typedef enum {
  GVATTR_STRING,
  GVATTR_BOOL,
  GVATTR_COLOR
} gvattr_t;

/* The -T output formats listed below are examples only, they are not definitive
 or inclusive,
 other outputs may use the flags now, or in the future

                   Default emit order is breadth first graph walk order
 EMIT_SORTED			emits nodes before edges
 EMIT_COLORS			emits colors before nodes or edge -Tfig
 EMIT_CLUSTERS_LAST		emits cluster after nodes and edges
 EMIT_PREORDER			emit in preorder traversal ???
 EMIT_EDGE_SORTED		emits edges before nodes

 GVDEVICE_DOES_PAGES		provides pagination support -Tps
 GVDEVICE_DOES_LAYERS		provides support for layers -Tps
 GVDEVICE_EVENTS		supports mouse events -Tgtk, -Txlib
 GVDEVICE_DOES_TRUECOLOR	supports alpha channel -Tpng, -Tgtk, -Txlib
 GVDEVICE_BINARY_FORMAT		Suppresses \r\n substitution for linends
 GVDEVICE_COMPRESSED_FORMAT	controls libz compression
 GVDEVICE_NO_WRITER		used when gvdevice is not used because device
 uses its own writer, -Tming, devil outputs   (FIXME seems to overlap
 OUTPUT_NOT_REQUIRED)

 GVRENDER_Y_GOES_DOWN		device origin top left, y goes down, otherwise
                                device origin lower left, y goes up
 GVRENDER_DOES_TRANSFORM	device uses scale, translate, rotate to do its
 own
                                coordinate transformations, otherwise
 coordinates
                                are pre-transformed
 GVRENDER_DOES_ARROWS		renderer has its own idea of arrow shapes
 (deprecated)
 GVRENDER_DOES_LABELS		basically, maps don't need labels
 GVRENDER_DOES_MAPS		renderer encodes mapping information for mouse
 events -Tcmapx -Tsvg
 GVRENDER_DOES_MAP_RECTANGLE	supports a 2 coord rectngle optimization
 GVRENDER_DOES_MAP_CIRCLE	supports a 1 coord + radius circle optimization
 GVRENDER_DOES_MAP_POLYGON	supports polygons (basically, -Tsvg uses
 anchors, so doesn't need to support any map shapes)
 GVRENDER_DOES_MAP_ELLIPSE	supports a 2 coord ellipse optimization
 GVRENDER_DOES_MAP_BSPLINE	supports mapping of splines
 GVRENDER_DOES_TOOLTIPS		can represent tooltip info -Tcmapx, -Tsvg
 GVRENDER_DOES_TARGETS		can represent target info (open link in a
 new tab or window)
 GVRENDER_DOES_Z		render support 2.5D representation -Tvrml
 GVRENDER_NO_WHITE_BG		don't paint white background, assumes white
 paper -Tps
 LAYOUT_NOT_REQUIRED 		don't perform layout -Tcanon
 OUTPUT_NOT_REQUIRED		don't use gvdevice for output (basically when
 agwrite() used instead) -Tcanon, -Txdot
 */

#define EMIT_SORTED (1 << 0)
#define EMIT_COLORS (1 << 1)
#define EMIT_CLUSTERS_LAST (1 << 2)
#define EMIT_PREORDER (1 << 3)
#define EMIT_EDGE_SORTED (1 << 4)
#define GVDEVICE_DOES_PAGES (1 << 5)
#define GVDEVICE_DOES_LAYERS (1 << 6)
#define GVDEVICE_EVENTS (1 << 7)
#define GVDEVICE_DOES_TRUECOLOR (1 << 8)
#define GVDEVICE_BINARY_FORMAT (1 << 9)
#define GVDEVICE_COMPRESSED_FORMAT (1 << 10)
#define GVDEVICE_NO_WRITER (1 << 11)
#define GVRENDER_Y_GOES_DOWN (1 << 12)
#define GVRENDER_DOES_TRANSFORM (1 << 13)
#define GVRENDER_DOES_ARROWS (1 << 14)
#define GVRENDER_DOES_LABELS (1 << 15)
#define GVRENDER_DOES_MAPS (1 << 16)
#define GVRENDER_DOES_MAP_RECTANGLE (1 << 17)
#define GVRENDER_DOES_MAP_CIRCLE (1 << 18)
#define GVRENDER_DOES_MAP_POLYGON (1 << 19)
#define GVRENDER_DOES_MAP_ELLIPSE (1 << 20)
#define GVRENDER_DOES_MAP_BSPLINE (1 << 21)
#define GVRENDER_DOES_TOOLTIPS (1 << 22)
#define GVRENDER_DOES_TARGETS (1 << 23)
#define GVRENDER_DOES_Z (1 << 24)
#define GVRENDER_NO_WHITE_BG (1 << 25)
#define LAYOUT_NOT_REQUIRED (1 << 26)
#define OUTPUT_NOT_REQUIRED (1 << 27)

typedef struct {
  int flags;
  double default_pad; /* graph units */
  char **knowncolors;
  int sz_knowncolors;
  color_type_t color_type;
} gvrender_features_t;

typedef struct {
  int flags;
  pointf default_margin;   /* left/right, top/bottom - points */
  pointf default_pagesize; /* default page width, height - points */
  pointf default_dpi;
} gvdevice_features_t;

#define LAYOUT_USES_RANKDIR (1 << 0)

typedef struct gvplugin_active_device_s {
  gvdevice_engine_t *engine;
  int id;
  gvdevice_features_t *features;
  const char *type;
} gvplugin_active_device_t;

typedef struct gvplugin_active_render_s {
  gvrender_engine_t *engine;
  int id;
  gvrender_features_t *features;
  const char *type;
} gvplugin_active_render_t;

typedef struct gvplugin_active_loadimage_t {
  gvloadimage_engine_t *engine;
  int id;
  const char *type;
} gvplugin_active_loadimage_t;

typedef struct gv_argvlist_s {
  char **argv;
  int argc;
  int alloc;
} gv_argvlist_t;

typedef struct gvdevice_callbacks_s {
  void (*refresh)(GVJ_t *job);
  void (*button_press)(GVJ_t *job, int button, pointf pointer);
  void (*button_release)(GVJ_t *job, int button, pointf pointer);
  void (*motion)(GVJ_t *job, pointf pointer);
  void (*modify)(GVJ_t *job, const char *name, const char *value);
  void (*del)(GVJ_t *job); /* can't use "delete" 'cos C++ stole it */
  void (*read)(GVJ_t *job, const char *filename, const char *layout);
  void (*layout)(GVJ_t *job, const char *layout);
  void (*render)(GVJ_t *job, const char *format, const char *filename);
} gvdevice_callbacks_t;

typedef int (*gvevent_key_callback_t)(GVJ_t *job);

typedef struct gvevent_key_binding_s {
  char *keystring;
  gvevent_key_callback_t callback;
} gvevent_key_binding_t;

typedef enum {
  MAP_RECTANGLE,
  MAP_CIRCLE,
  MAP_POLYGON,
} map_shape_t;

typedef enum {
  ROOTGRAPH_OBJTYPE,
  CLUSTER_OBJTYPE,
  NODE_OBJTYPE,
  EDGE_OBJTYPE
} obj_type;

/* If this enum is changed, the implementation of xbuf and xbufs in
 * gvrender_core_dot.c will probably need to be changed.
 */
typedef enum {
  EMIT_GDRAW,
  EMIT_CDRAW,
  EMIT_TDRAW,
  EMIT_HDRAW,
  EMIT_GLABEL,
  EMIT_CLABEL,
  EMIT_TLABEL,
  EMIT_HLABEL,
  EMIT_NDRAW,
  EMIT_EDRAW,
  EMIT_NLABEL,
  EMIT_ELABEL,
} emit_state_t;

typedef struct events_s events_t;

struct events_s {
  char *onfocusin;
  char *onfocusout;
  char *onactivate;
  char *onclick;
  char *onmousedown;
  char *onmouseup;
  char *onmouseover;
  char *onmousemove;
  char *onmouseout;
  char *onunload;
  char *onabort;
  char *onerror;
  char *onresize;
  char *onscroll;
  char *onzoom;
  char *onbegin;
  char *onend;
  char *onrepeat;
};

typedef struct obj_state_s obj_state_t;

struct obj_state_s {
  obj_state_t *parent;
  events_t events;

  obj_type type;
  union {
    graph_t *g;
    graph_t *sg;
    node_t *n;
    edge_t *e;
  } u;

  emit_state_t emit_state;

  gvcolor_t pencolor, fillcolor, stopcolor;
  int gradient_angle;
  float gradient_frac;
  pen_type pen;
  fill_type fill;
  double penwidth;
  char **rawstyle;

  double z, tail_z, head_z; /* z depths for 2.5D renderers such as vrml */

  /* fully substituted text strings */
  char *label;
  char *xlabel;
  char *taillabel;
  char *headlabel;

  char *url; /* if GVRENDER_DOES_MAPS */
  char *id;
  char *labelurl;
  char *tailurl;
  char *headurl;

  char *tooltip; /* if GVRENDER_DOES_TOOLTIPS */
  char *labeltooltip;
  char *tailtooltip;
  char *headtooltip;

  char *target; /* if GVRENDER_DOES_TARGETS */
  char *labeltarget;
  char *tailtarget;
  char *headtarget;

  int explicit_tooltip : 1;
  int explicit_tailtooltip : 1;
  int explicit_headtooltip : 1;
  int explicit_labeltooltip : 1;
  int explicit_tailtarget : 1;
  int explicit_headtarget : 1;
  int explicit_edgetarget : 1;
  int explicit_tailurl : 1;
  int explicit_headurl : 1;
  int labeledgealigned : 1;

  /* primary mapped region - node shape, edge labels */
  map_shape_t url_map_shape;
  int url_map_n; /* number of points for url map if GVRENDER_DOES_MAPS */
  pointf *url_map_p;

  /* additonal mapped regions for edges */
  int url_bsplinemap_poly_n; /* number of polygons in url bspline map
                              if GVRENDER_DOES_MAPS &&
                              GVRENDER_DOES_MAP_BSPLINES */
  int *url_bsplinemap_n; /* array of url_bsplinemap_poly_n ints
                          of number of points in each polygon */
  pointf *url_bsplinemap_p; /* all the polygon points */

  int tailendurl_map_n; /* tail end intersection with node */
  pointf *tailendurl_map_p;

  int headendurl_map_n; /* head end intersection with node */
  pointf *headendurl_map_p;
};

/* Note on units:
 *     points  - a physical distance (1/72 inch) unaffected by zoom or dpi.
 *     graph units - related to physical distance by zoom.  Equals points at
 * zoom=1
 *     device units - related to physical distance in points by dpi/72
 */

struct GVJ_s {
  GVC_t *gvc;         /* parent gvc */
  GVJ_t *next;        /* linked list of jobs */
  GVJ_t *next_active; /* linked list of active jobs (e.g. multiple windows) */

  GVCOMMON_t *common;

  obj_state_t *obj; /* objects can be nested (at least clusters can)
                            so keep object state on a stack */
  char *input_filename;
  int graph_index;

  const char *layout_type;

  const char *output_filename;
  FILE *output_file;
  char *output_data;
  unsigned int output_data_allocated;
  unsigned int output_data_position;

  const char *output_langname;
  int output_lang;

  gvplugin_active_render_t render;
  gvplugin_active_device_t device;
  gvplugin_active_loadimage_t loadimage;
  gvdevice_callbacks_t *callbacks;
  pointf device_dpi;
  boolean device_sets_dpi;

  void *display;
  int screen;

  void *context;            /* gd or cairo surface */
  boolean external_context; /* context belongs to caller */
  char *imagedata;          /* location of imagedata */

  int flags; /* emit_graph flags */

  int numLayers; /* number of layers */
  int layerNum;  /* current layer - 1 based*/

  point pagesArraySize;  /* 2D size of page array */
  point pagesArrayFirst; /* 2D starting corner in */
  point pagesArrayMajor; /* 2D major increment */
  point pagesArrayMinor; /* 2D minor increment */
  point pagesArrayElem;  /* 2D coord of current page - 0,0 based */
  int numPages;          /* number of pages */

  boxf bb;         /* graph bb with padding - graph units */
  pointf pad;      /* padding around bb - graph units */
  boxf clip;       /* clip region in graph units */
  boxf pageBox;    /* current page in graph units */
  pointf pageSize; /* page size in graph units */
  pointf focus;    /* viewport focus - graph units */

  double zoom;  /* viewport zoom factor (points per graph unit) */
  int rotation; /* viewport rotation (degrees)  0=portrait, 90=landscape */

  pointf view;    /* viewport size - points */
  boxf canvasBox; /* viewport area - points */
  pointf margin;  /* job-specific margin - points */

  pointf dpi; /* device resolution device-units-per-inch */

  unsigned int width;  /* device width - device units */
  unsigned int height; /* device height - device units */
  box pageBoundingBox; /* rotated boundingBox - device units */
  box boundingBox; /* cumulative boundingBox over all pages - device units */

  pointf scale;       /* composite device to graph units (zoom and dpi) */
  pointf translation; /* composite translation */
  pointf devscale;    /* composite device to points: dpi, y_goes_down */

  boolean fit_mode, needs_refresh, click, has_grown, has_been_rendered;

  unsigned char button; /* active button */
  pointf pointer;       /* pointer position in device units */
  pointf oldpointer;    /* old pointer position in device units */

  void *current_obj; /* graph object that pointer is in currently */

  void *selected_obj;   /* graph object that has been selected */
                        /* (e.g. button 1 clicked on current obj) */
  char *active_tooltip; /* tooltip of active object - or NULL */
  char *selected_href;  /* href of selected object - or NULL */
  gv_argvlist_t
      selected_obj_type_name; /* (e.g. "edge" "node3" "e" "->" "node5" "") */
  gv_argvlist_t selected_obj_attributes; /* attribute triplets: name, value,
                                            type */
  /* e.g. "color", "red", GVATTR_COLOR,
          "style", "filled", GVATTR_BOOL, */

  void *window; /* display-specific data for gvrender plugin */

  /* keybindings for keyboard events */
  gvevent_key_binding_t *keybindings;
  int numkeys;
  void *keycodes;
};

#ifdef __cplusplus
}
#endif
#endif /* GVCJOB_H */
